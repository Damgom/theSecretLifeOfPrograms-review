# 정수를 비트로 표현하는 방법

비트를 사용해 수를 표현하는 방법

### 양의 정수 표현

우리는 일상 생활에서 10진수(decimal number) 체계를 사용한다. 10진수 체계에서는 10가지 기호인 숫자(digit) 를 상자에 담을 수 있다.
예를 들어 1025라는 숫자를 상자에 담는다면  
|천의 자리|백의 자리|십의 자리|일의 자리| 
|:-:|:-:|:-:|:-:|
|10^3|10^2|10^1|10^0|
|1|0|2|5|

각 상자의 위치에 해당하는 밑(base) 의 거듭제곱과 각 자리에 들어간 수를 곱한 값들의 합이다.
10진수를 사용하기 때문에 각 상자의 밑은 10이며, 각 상자에 담는다는 것은 각 자리에 대응하는 숫자를 위치시키는 것으로 이해할 수 있다.  
  
이와 같은 방식을 통해 비트로 수를 표현할 수 있다. 비트는 2진수 체계이기 때문에 각 자리 또는 상자에 들어갈 수 있는 수는 0과 1이다. 그리고 2진수 체계이기 때문에 밑(base) 은 2이다.  
1025를 2진수로 표현한다면 2^10 * 1 + 2^0 * 1이므로 다음과 같다.  

|1|0|0|0|0|0|0|0|0|0|1|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|

10진수에서는 1025가 4자리 숫자이지만, 2진수로 표현한다면 11자리 숫자(11비트 수) 가 된다.
2진수 비트로 표현 된 수에서 가장 오른쪽(가장 작은 자릿수)의 비트를 `LSB(Least Significant Bit)`, 반대로 가장 왼쪽(가장 큰 자릿수)의 비트를 `MSB(Most Significant Bit)`라고 부른다.  
가장 오른쪽 비트를 변경하면 값이 가장 작게 변경되고, 가장 왼쪽의 비트를 변경하면 가장 크게 변하기 때문

|0|0|0|0|0|1|0|0|0|0|0|0|0|0|0|1|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|

이 숫자는 1025를 2진법으로 나타냈지만 11자리가 아닌 16자리이다. 가장 왼쪽의 상자보다 더 왼쪽에 0을 추가하는 것을 `리딩제로(leading zero)` 라고 하며,
컴퓨터는 미리 정해진 수의 비트를 한 덩어리로 사용하도록 만들어졌기 때문에 2진수 체계에서 항상 일정한 갯수의 비트를 사용해 값을 표현하는 경우가 있다. 

### 이진수 덧셈

2진수에서 각 비트를 LSB 에서 MSB 쪽으로 더하며, 결과가 1보다 크면 1을 다음 자리(왼쪽) 으로 올린다.  

    ex. 0 0 1
      + 1 0 1
        -----
        1 1 0
`AND`와 `XOR` 논리 연산자로 2진수의 각 자리 덧셈을 수행할 수 있다.

|A|B|A AND B|A+B|A XOR B|A|B| 
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|0|0|0|00|0|0|0|
|0|1|0|01|1|0|1|
|1|0|0|01|1|1|0|
|1|1|1|10|0|1|1|

덧셈의 결과가 사용할 수 있는 비트 추를 초과 할 경우 `오버플로우(overflow)`가 발생한다. 오버플로우는 MSB 에서 올림이 발생했다는 뜻이다.
4비트 덧셈에서 1001과 1000을 더한 결과는 10001 이지만 MSB 왼쪽에 사용할 수 있는 비트가 없기 때문에 결과가 0001이 된다.
컴퓨터에는 `조건 코드 레지스터(condition code register)`라는 것이 존재하고, 이곳에 오버플로 비트를 담기 때문에 이곳에 담긴 비트 값을 통해 오버플로우 여부를 확인 할 수 있다.  
한 수에서 다른 수를 빼는 것은 한 수에 다른 수의 음수를 더하는 것과 같다. MSB 위쪽에서 1을 빌려오는 경우를 `언더플로(underflow)`라고 부른다.


### 음수 표현

4비트를 쓴다고 가정하고 시작해보자. 4비트를 쓴다고 해서 0부터 15까지 16개의 수를 표현할 수 있다는 뜻은 아니다. 언어는 문맥과 의미를 통해 작용하므로, 비트를 해석하는 새로운 문맥을 만들어 낼 수 있다.
> 부호와 크기

우리는 실생활에서 + 기호나 - 기호를 통해 양수와 음수를 표현한다. 이처럼 비트에서도 MSB 에 부호의 역할을 부여해 동일하게 구분하는 방법이 존재한다.
- +5 표현

|0|1|0|1|
|:-:|:-:|:-:|:-:|

- -5 표현

|1|1|0|1|
|:-:|:-:|:-:|:-:|

4비트 수 0101과 1101은 MSB 의 차이가 있다. MSB 가 0이면 +이고 1이면 -임을 뜻한다.
이렇게 MSB 를 이용해 부호를 표현하는 방법을  
`부호와 크기(Sign and Magnitude)표현법`이라고 한다.  
하지만 이 방법은 2가지 이유로 잘 활용되지 않는다. 
- 0을 표현하는 방법이 +0과 -0 2가지라서 비용이 낭비된다.
- AND 와 XOR 을 이용한 덧셈 계산을 간편하게 할 수 없다.

> 1의 보수

음수를 표현하는 또 다른 방법으로 양수의 모든 비트를 뒤집는 방법이 있다. 이것을 `1의 보수(one's complement)표현법` 이라 한다. 비트들을 부호 비트와 나머지 수로 나누어지며, NOT 연산을 통해 보수를 얻는다.

- +7 표현

|0|1|1|1|
|:-:|:-:|:-:|:-:|

- -7 표현

|1|0|0|0|
|:-:|:-:|:-:|:-:|

동일하게 0을 두가지로 표현한다는 문제가 존재하며, MSB 에서 올림이 발생한 경우 다시 LSB 로 전달하는 `순환 올림(end-around carry)`을 해야 한다.

>2의 보수

특별한 하드웨어의 추가 없이 XOR 과 AND 연산만 사용해야 한다면 `2의 보수(two's complement)표현법`을 사용할 수 있다.
양수 1을 더했을 때 0이 나오도록 하는 숫자를 -1로 정한다. 이 때 MSB 에서 올림이 발생하면 그 값을 버린다. 1의 보수 표현법과 동일하게 MSB 를 부호로 사용한다.
앞선 규칙대로 4비트 수 0001에서 1111을 더하면 0000을 얻을 수 있다. 그러므로 1111을 -1로 정한다.  
정리하면 0과 1을 서로 뒤집은 다음 2진수 1을 더해주는 방법이다.
- +4 표현

|0|1|0|0|
|:-:|:-:|:-:|:-:|

- -4 표현

|1|0|1|1|
|:-:|:-:|:-:|:-:|  

|0|0|0|1|
|:-:|:-:|:-:|:-:|  

위의 두 2진수를 더한 값이 -4가 된다.

|1|1|0|0|
|:-:|:-:|:-:|:-:|

2의 보수법에서는 0을 표현하는 방법이 1가지 이다.